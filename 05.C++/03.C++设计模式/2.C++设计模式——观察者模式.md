# C++设计模式——观察者模式


```cpp
#include<iostream>
#include<list>
#include<string> 
using namespace std;
class Observer;
class Subject        //主题
{
public:
    virtual void notify()=0;
    virtual void attach(Observer *o)=0;
    virtual void detach(Observer *o)=0;
    string getState()
    {
        return state;
    }
    void setState(string s)
    {
        state = s;
    }
protected:    
    string state;
    list<Observer*> l;
    /*
    我的理解：
        关键是主题类中有观察者实例的指针；
        通过指针调用观察者的函数（函数传参，发消息）。
    注：子类指针赋值给基类，没有问题（不会丢失子类独有的方法等、没有语法问题）。
    */
};
class Observer
{
public:
    virtual void update(Subject *s)
    {
        cout << "Observer::update" << endl;
    }
};
class ConcreteSubject:public Subject
{
public:
    virtual void notify()
    {
        list<Observer*>::iterator it = l.begin();
        while(it != l.end())
        {
            (*it)->update(this);
            it++;
        }
    }
    virtual void attach(Observer *o)
    {
        l.push_back(o);
    }
    virtual void detach(Observer *o)
    {
        l.remove(o);
    }
};
class Observer1:public Observer
{
public:
    virtual void update(Subject *s)
    {
        cout << "Observer1::update Subject's state is " << s->getState() << endl;
    }
};
class Observer2:public Observer
{
public:
    virtual void update(Subject *s)
    {
        cout << "Observer2::update Subject's state is " << s->getState() << endl;
    }
};
 
int main()
{
    Observer1 o1;
    Observer2 o2;
    ConcreteSubject cs;
    cs.attach(&o1);
    cs.attach(&o2);
    cs.setState("state1");
    cs.notify();
    cs.setState("state2");
    cs.notify();
    return 0;
}
```

作者 [@wangbin][3]     
2018 年 8月 15日 


