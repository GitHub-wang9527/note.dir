# C++设计模式——装饰者模式

> https://blog.csdn.net/K346K346/article/details/58056854

具体实现：  
&emsp;&emsp;创建一个具体构建的类；然后为其加装饰。  
&emsp;&emsp;它们有共同的基类。

```cpp
#include<iostream>
#include<string>
using namespace std;
class Beverage
{
public:
	string describtion;
	virtual string getDescribition()//抽象主键，如果不设计成virtural,并不能动态的改变
	{
		return describtion;
	}
	virtual double cost()=0;
	virtual ~Beverage(){}
};
class CondimentDecorator:public Beverage  //装饰组件抽象类
{
public:
	virtual string getDescribition()=0;//装饰者与被装饰者必须有一样的类型，利用继承达到类型匹配
};
class Expresso :public Beverage//具体组件
{
public:
	Expresso()
	{
		describtion="Expresso";
	}
	double cost()
	{
		return 1.99;
	}
};
class DarkRost :public Beverage
{
public:
	DarkRost()
	{
		describtion="DarkRost";
	}
	double cost()
	{
		return 0.99;
	}
};
class HouseBlend:public Beverage
{
public:
	HouseBlend()
	{
		describtion="HouseBlend";
	}
	double cost()
	{
		return 0.89;
	}
};
class Mocha:public CondimentDecorator//具体装饰者组件
{
private:
	Beverage *beverage;
public:
	Mocha(Beverage *beverage)
	{
		this->beverage=beverage;
	}
	string getDescribition()
	{
		 return beverage->getDescribition() + " ,Mocha";
	}
	double cost()
	{
		return 0.20+beverage->cost();
	}
};
class Whip:public CondimentDecorator
{
private:
	Beverage *beverage;
	string addstr;
public:
	Whip(Beverage *beverage)
	{
		this->beverage=beverage;
	}
	string getDescribition()
	{
		
		return beverage->getDescribition()+" ,Whip";
	}
	double cost()
	{
		return 0.1+beverage->cost();
	}
};
class Soy:public CondimentDecorator
{
private:
	Beverage *beverage;
public:
	Soy(Beverage *beverage)
	{
		this->beverage=beverage;
	}
	string getDescribition()
	{
		return beverage->getDescribition()+" ,Soy";
	}
	double cost()
	{
		return 0.15+beverage->cost();
	}
};
int main()
{
	Beverage *beverage=new Expresso();
	cout<<beverage->getDescribition()
	    <<" $"<<beverage->cost()<<endl;
    Beverage *beverage1=new DarkRost();
    beverage1=new Mocha(beverage1);
    beverage1=new Mocha(beverage1);
    beverage1=new Whip(beverage1);
    cout<<beverage1->getDescribition()
        <<" $"<<beverage1->cost()<<endl;
	delete beverage;
	delete beverage1;
	return 0;
}
```

&emsp;&emsp;将装饰者与组件组合时，就是加入新的行为。所得的行为，不是继承自超类，而是由组合对象得来的。  
&emsp;&emsp;利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。  
&emsp;&emsp;然而，如果能够利用组合的做法扩展对象的行为，就可以运行时动态的扩展(在类中含有基类指针，使用多态扩展)。  





