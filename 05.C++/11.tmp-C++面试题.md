> https://www.zhihu.com/search?type=content&q=C%2B%2B%E9%9D%A2%E8%AF%95%E9%A2%98

### 小知识点
```cpp

    
2、结构体字节对齐（系统是n字节对齐）
    每个成员的起始位置是min(成员大小,n)的整数倍
    结构体是n的整数倍
    
    
4、何时调用复制构造函数（即拷贝构造函数）
    按值传递对象
    函数返回对象（编译器可能优化）  
        PS: 参见 https://blog.csdn.net/wodabawang/article/details/105218236
            这个优化很智能
    复制初始化，即用一个对象初始化另一个对象
    
6、 C++是不是类型安全的？
    不是。两个不同类型的指针之间可以强制转换
    
7、分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。
    BOOL : if ( !a ) or if(a)
    int : if ( a == 0)
    float : const EXPRESSION EXP = 0.000001
        if ( a < EXP && a >-EXP)
    pointer : if ( a != nullptr) or if(a == nullptr)
    
8、const 与 #define 的比较 ，const有什么优点?
    const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。  
    有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。

9、成员初始化列表
    const和引用变量必须使用初始化列表进行初始化
    
10、虚继承
    普通继承：可以使用A::a,B::a进行访问呢
    虚继承的作用：防止菱形继承可能出现的冲突。
    虚继承构造函数初始化：必须由最终的派生类 D 来初始化虚基类 A，直接派生类 B 和 C 对 A 的构造函数的调用是无效的。
    
11、虚继承和普通继承，构造函数执行顺序
    虚继承：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何。
        编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数。
    普通继承：就是按照构造函数出现的顺序依次调用的
    
13、sizeof和strlen
    sizeof是一个操作符，strlen是库函数。
    sizeof的参数是数据的类型、变量和表达式，而strlen只能以结尾为‘\0’的字符串作参数。
    编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。
    数组做sizeof的参数不退化，传递给strlen就退化为指针了    

14、指针常量和常量指针
    int * const p       //指针常量
        * const p，const修饰的是p，p的指向不可以改变
    const int *p        //常量指针
        const 修饰的是*p，p可变，*p不可变

16、虚析构函数
    在虚表中，子类的虚析构函数会覆盖掉基类的虚析构函数。然后子类析构函数调用父类析构函数
```


### 数组和指针
```cpp
数组
    int a[100] = {0}；//这是在栈上的
    int a[100] = malloc（sizeof（int））；//这是在堆上的（？？？这样还是数组吗）

数组和指针的比较
1、概念
    数组：数组是用于储存多个相同类型数据的集合。
    指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。
2、同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝
3、数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。

4、修改
char *p = “world”; // 注意p 指向常量字符串
p[0] = ‘X’; // 编译器不能发现该错误，运行时错误

5、大小
char a[] = "hello world";
char *p = a;
cout<< sizeof(a) << endl; // 12 字节
cout<< sizeof(p) << endl; // 4 字节

//当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针
void Func(char a[100]){
    cout<< sizeof(a) << endl; // 4 字节而不是100 字节
}
//防止蜕化（数组引用）
void Func(char (&a)[100]){
    cout<< sizeof(a) << endl; // 100 字节
}
```

### 引用
```cpp
1、特点
    声明的时候必须初始化
    不能再把该引用名作为其他变量名的别名
    不能建立数组的引用。（数组元素不可以是引用）  ？？？TODO

3、在什么时候需要使用“常引用”？
    如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

string foo( );
void bar(string & s);
那么下面的表达式将是非法的：
bar(foo( ));
bar("hello world");

原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。
而试图将一个const类型的对象转换为非const类型，这是非法的。
引用型参数应该在能被定义为const的情况下，尽量定义为const 。


4、将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?
好处：在内存中不产生被返回值的副本

注意事项：
不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。

不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，但面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。

可以返回类成员的引用，但最好是const。


5、操作符重载和引用
流操作符重载返回值申明为“引用”：
流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。

赋值操作符=重载返回值申明为“引用”：
这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。

（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 

```

### 右值引用
> https://www.zhihu.com/question/22111546/answer/30801982
```cpp
移动语义
    移交变量（资源）的所有权
完美转发
```

思考？？
```cpp
右值引用的C++，函数返回值是不是不该使用引用了？？
    不是，他们不是同一个场景。比如返回类成员变量还是很有用的
```

```cpp

QString s1;
s1="aaa";

QString s1("aaa");
"以上2中方式有什么区别？"
"第二种开销小"
"为什么开销小？"
"第二种构造了2次"
PS：一个是初始化构造 一个拷贝构造。初始化构造开销小
```


```cpp
utf-8是unicode编码的一种
debug和release库：release不含调试信息，并且对代码 进行了优化
```

#### dll的加载方式
```cpp
动态库的隐示加载
    需要头文件 lib文件 dll文件 程序运行时dll也要加载到内容 但多个程序使用dll时  内存中只用一份dll
动态库的显示加载
    只需要dll文件即可 程序运行时不加载dll 只有在loadlibrary 使用库函数时才加载dll
动态库的延迟加载
    其实是动态库的隐示加载和显示加载的合并
    需要头文件 lib文件 dll文件 只是程序运行时不加载dll，在程序使用时才加载dll，此时的原理与显示加载的原理一样。
    注意需要配置编译器选项：link>delay load dll一项需要填入加载的动态库文件
```

#### 堆空间和栈空间
```cpp
栈空间作为一个严格后进先出的数据结构。
可用空间永远都是一块连续的区域。
栈空间有计算机底层的支持，压栈和出栈都有专门的指令，效率较高
```


