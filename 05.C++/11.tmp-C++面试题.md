
### 小知识点
```cpp
10、虚继承
    普通继承：可以使用A::a,B::a进行访问呢
    虚继承的作用：防止菱形继承可能出现的冲突。
    虚继承构造函数初始化：必须由最终的派生类 D 来初始化虚基类 A，直接派生类 B 和 C 对 A 的构造函数的调用是无效的。
    
11、虚继承和普通继承，构造函数执行顺序
    虚继承：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何。
        编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数。
    普通继承：就是按照构造函数出现的顺序依次调用的
    
13、sizeof和strlen
    sizeof是一个操作符，strlen是库函数。
    sizeof的参数是数据的类型、变量和表达式，而strlen只能以结尾为‘\0’的字符串作参数。
    编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。
    数组做sizeof的参数不退化，传递给strlen就退化为指针了    
```


### 数组和指针
```cpp


5、大小
char a[] = "hello world";
char *p = a;
cout<< sizeof(a) << endl; // 12 字节
cout<< sizeof(p) << endl; // 4 字节

//当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针
void Func(char a[100]){
    cout<< sizeof(a) << endl; // 4 字节而不是100 字节
}
//防止蜕化（数组引用）
void Func(char (&a)[100]){
    cout<< sizeof(a) << endl; // 100 字节
}
```

### 引用
```cpp

5、操作符重载和引用
流操作符重载返回值申明为“引用”：
流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。

赋值操作符=重载返回值申明为“引用”：
这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。

（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 

```


```cpp

QString s1;
s1="aaa";

QString s1("aaa");
"以上2中方式有什么区别？"
"第二种开销小"
"为什么开销小？"
"第二种构造了2次"
PS：一个是初始化构造 一个拷贝构造。初始化构造开销小
```

#### dll的加载方式
```cpp
动态库的隐示加载
    需要头文件 lib文件 dll文件 程序运行时dll也要加载到内容 但多个程序使用dll时  内存中只用一份dll
动态库的显示加载
    只需要dll文件即可 程序运行时不加载dll 只有在loadlibrary 使用库函数时才加载dll
动态库的延迟加载
    其实是动态库的隐示加载和显示加载的合并
    需要头文件 lib文件 dll文件 只是程序运行时不加载dll，在程序使用时才加载dll，此时的原理与显示加载的原理一样。
    注意需要配置编译器选项：link>delay load dll一项需要填入加载的动态库文件
```

