

结构体字节对齐（系统是n字节对齐）
    每个成员的起始位置是min(成员大小,n)的整数倍
    结构体是n的整数倍

C++是不是类型安全的？
    不是。两个不同类型的指针之间可以强制转换
    
分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。
    BOOL : if ( !a ) or if(a)
    int : if ( a == 0)
    float : const EXPRESSION EXP = 0.000001
        if ( a < EXP && a >-EXP)
    pointer : if ( a != nullptr) or if(a == nullptr)
    
const 与 #define 的比较 ，const有什么优点?
    const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。  
    有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。

utf-8是unicode编码的一种

debug和release库：release不含调试信息，并且对代码 进行了优化



指针指向的常量字符串不可以被修改

## dll的加载方式

+ 动态库的隐示加载

    需要头文件 lib文件 dll文件 程序运行时dll也要加载到内容 但多个程序使用dll时  内存中只用一份dll

+ 动态库的显示加载

    只需要dll文件即可 程序运行时不加载dll 只有在loadlibrary 使用库函数时才加载dll

+ 动态库的延迟加载

    其实是动态库的隐示加载和显示加载的合并
    需要头文件 lib文件 dll文件 只是程序运行时不加载dll，在程序使用时才加载dll，此时的原理与显示加载的原理一样。
    注意需要配置编译器选项：link>delay load dll一项需要填入加载的动态库文件

## C

不能建立数组的引用是说，数组的元素不能是引用。（C语法有点难搞）

### 数组和指针

数组和指针的比较
    1、数组是用于储存多个相同类型数据的集合。指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。
    2、同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝
    3、数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。

```cpp
//当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针
void Func(char a[100]){
}
//防止蜕化（数组引用）
void Func(char (&a)[100]){
}
```

### sizeof和strlen
    sizeof是一个操作符，strlen是库函数。
    sizeof的参数是数据的类型、变量和表达式，而strlen只能以结尾为‘\0’的字符串作参数。
    编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。
    数组做sizeof的参数不退化，传递给strlen就退化为指针了  


## 虚继承

```cpp
    class A;
    class B:public A
    class C:public A
    class D:public B,C
```
    如上，菱形继承，D中需要继承2份A的原始变量，会出现错误。虚继承就是为了解决这个问题。

```cpp
    class A;
    class B:virtual public A
    class C:virtual public A
    class D:public B,C
```
    虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）。本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

    普通继承是按照构造函数出现的顺序依次调用的。对于虚继承来说，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数。



