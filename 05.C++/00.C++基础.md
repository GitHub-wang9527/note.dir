
## 章节目录

[TOC]

---

C++笔记，部分内容来自[github分享](https://github.com/0voice/cpp_new_features)

## 1、内存分区模型

### 1.1 C++程序在执行时，将内存大方向划分为4个区域

+ 代码区：存放函数体的二进制代码，由操作系统进行管理的

&emsp;&emsp;存放 CPU 执行的机器指令
&emsp;&emsp;代码区是**共享的**，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
&emsp;&emsp;代码区是**只读的**，使其只读的原因是防止程序意外地修改了它的指令

+ 全局区：存放全局变量和静态变量以及常量

&emsp;&emsp;**全局变量和静态变量**存放在此
&emsp;&emsp;全局区还包含了**常量区, 存放 const修饰的全局常量 和 字符串常量**
&emsp;&emsp;该区域的数据在程序结束后由操作系统释放

+ 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等

&emsp;&emsp;**局部常量**在栈区
&emsp;&emsp;由编译器自动分配释放, 存**放函数的参数值，局部变量**等

+ 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

&emsp;&emsp;用new开辟的对象（手动释放）

### 1.2 堆栈空间的比较

&emsp;&emsp;栈空间是一个严格后进先出的数据结构，有计算机底层的支持，压栈和出栈都有专门的指令和寄存器，效率较高。
&emsp;&emsp;栈空间是一块连续的区域

&emsp;&emsp;堆空间逻辑上是连续的，物理上不是连续的（多个malloc之间）。malloc/free操作很容易造成堆碎片

### 1.3 内存管理

&emsp;&emsp;在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。
&emsp;&emsp;malloc申请n字节的空间，实际申请到的block空间比n大，其中存放了一些控制块。

## 2、引用

### 2.1 const 与 指针

+ 常量指针(本质是指针)

&emsp;&emsp;const int * p1 = &a; 
&emsp;&emsp;指向常量的指针；
&emsp;&emsp;const修饰的是指针，可以修改**指针的指向**

+ 指针常量(本质是常量)

&emsp;&emsp;int * const p=&a;
&emsp;&emsp;const修饰的是常量，可以修改**指针指向的值**

### 2.2 指针常量和引用

&emsp;&emsp;引用的本质在c++内部实现是一个指针常量，所以指向不可改
&emsp;&emsp;编译会将int& ref = a 自动转换为 int* const ref = &a

&emsp;&emsp;常量引用主要用来修饰形参，防止误操作：const int& v

### 2.3 引用的特点

&emsp;&emsp;引用必须初始化
&emsp;&emsp;引用在初始化后，不可以改变
&emsp;&emsp;引用可以作为返回值

## 3、 函数提高

+ 函数占位符

&emsp;&emsp;占位符可以拥有默认参数，如果占位符没有写默认参数，那么调用的时候必须填写。包含占位符的函数声明如下：
&emsp;&emsp;&emsp;&emsp;void func2(int a,int = 1){}

+ 函数重载

1) 参数int & a 和参数 const inst & a是不同的；
2) func2(int a, int b = 10)和func2(int a)是相同的，使用func2(0)的时候无法区分想要调用的是第一个还是第二个函数

## 4、 对象的初始化和清理

### 4.1 C++中 struct和class唯一的区别就在于 默认的访问权限不同

### 4.2 构造函数

#### 4.2.1 普通构造函数

```cpp
	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); 
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构

	//2.3 隐式转换法
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 

	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	//Person p5(p4);
```

#### 4.2.2 拷贝构造函数

+ 拷贝构造函数的定义

```cpp
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
```

+ 拷贝构造函数调用时机

&emsp;&emsp;当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数会被调用。

&emsp;&emsp;C++中拷贝构造函数调用时机通常有如下三种情况：

&emsp;&emsp;1) 使用一个已经创建完毕的对象来初始化一个新对象

```cpp
	Person man(100); 
	Person newman(man);     // 调用拷贝构造函数
	Person newman2 = man;   // 拷贝构造
    newman2 = man;          // 调用 = 操作符
    
```
&emsp;&emsp;2) 值传递的方式给函数参数传值
&emsp;&emsp;3) 以值方式返回局部对象

#### 4.2.3  编译器自动添加的函数

&emsp;&emsp;默认情况下，c++编译器至少给一个类添加3个函数

```cpp
1) 默认构造函数(无参，函数体为空)
2) 默认析构函数(无参，函数体为空)
3) 默认拷贝构造函数，对属性进行值拷贝（浅拷贝）
```

&emsp;&emsp;如果用户自定义**有参构造函数**，c++不在提供默认无参构造，但是会提供默认拷贝构造。如果用户**自定义拷贝构造函数**，c++不会再提供**其他构造函数**

#### 4.2.4  构造函数执行顺序

1) 构造的顺序是 ：先调用对象成员的构造，再调用本类构造
2) 析构顺序与构造相反

#### 4.2.5 初始化列表

+ 必须使用参数列表初始化的情况
&emsp;&emsp;const和引用变量必须使用初始化列表进行初始化；
&emsp;&emsp;没有默认构造函数的类成员，包括基类没有默认构造函数；

&emsp;&emsp;如果在类中声明了成员变量，并且构造函数初始化列表中也初始化了该成员变量，则只执行参数初始化列表中的构造。

#### 4.2.6 静态成员

+ 静态成员变量

&emsp;&emsp;所有对象共享同一份数据
&emsp;&emsp;在编译阶段分配内存
&emsp;&emsp;类内声明，类外初始化

+ 静态成员函数

&emsp;&emsp;所有对象共享同一个函数
&emsp;&emsp;静态成员函数只能访问静态成员变量

### 4.3 C++对象模型和this指针

#### 4.3.1成员变量和成员函数分开存储

&emsp;&emsp;非静态成员变量占对象空间
&emsp;&emsp;静态成员变量不占对象空间
&emsp;&emsp;函数也不占对象空间，所有函数共享一个函数实例
&emsp;&emsp;静态成员函数也不占对象空间	

+ 总结

&emsp;&emsp;类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上	

#### 4.3.2 this指针

&emsp;&emsp;我们知道在C++中成员变量和成员函数是分开存储的。每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。

&emsp;&emsp;那么问题是：这一块代码是如何区分那个对象调用自己的呢？

&emsp;&emsp;c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**。

+ this指针的用途：

&emsp;&emsp;当形参和成员变量同名时，可用this指针来区分
&emsp;&emsp;在类的非静态成员函数中返回对象本身，可使用return *this

#### 4.3.3 空指针访问成员函数

```cpp
Person *p=nullprt;
p->country()		// 如果country方法中没有使用this，函数可以正常运行
```

&emsp;&emsp;在类中使用成员变量和成员函数，可以不加this；编译器在展开时，自动添加this。
&emsp;&emsp;想到了一种写法 if (this == nullptr) return; **啧啧**

#### 4.3.4 const 修饰成员函数和类

+ 常函数

&emsp;&emsp;成员函数后加const后我们称为这个函数为常函数
&emsp;&emsp;常函数内不可以修改成员属性
&emsp;&emsp;成员属性声明时加关键字mutable后，在常函数中依然可以修改

+ 常对象

&emsp;&emsp;声明对象前加const称该对象为常对象
&emsp;&emsp;常对象只能调用常函数

### 4.4 友元

&emsp;&emsp;友元的目的就是让一个函数或者类 访问另一个类中私有成员。友元有3种形式，具体如下：

&emsp;&emsp;&emsp;&emsp;1) 全局函数做友元
&emsp;&emsp;&emsp;&emsp;2) 类做友元
&emsp;&emsp;&emsp;&emsp;3) 成员函数做友元

+ 注意

&emsp;&emsp;友元关系不能被继承。 
&emsp;&emsp;友元关系是单向的，不具有交换性
&emsp;&emsp;友元关系不具有传递性。


### 4.5 运算符重载

&emsp;&emsp;**见其它笔记文件**

### 4.6 继承

#### 4.6.1 继承和访问权限

&emsp;&emsp;public继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, private
&emsp;&emsp;protected继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, private
&emsp;&emsp;private继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, private

&emsp;&emsp;子类继承父类时，也将父类私有变量/方法继承了过来，只是对子类不可见，不可操作。
&emsp;&emsp;private只有当前类和友元可以访问。
&emsp;&emsp;子类对象加作用域可以访问到父类同名成员

#### 4.6.2 抽象类和纯虚函数

&emsp;&emsp;纯虚函数，语法：virtual 返回值类型 函数名 （参数列表）= 0 。
&emsp;&emsp;抽象类：类中包含的纯虚函数的类叫做抽象类，抽象类不可以实例化。

#### 4.6.3 多态和虚析构函数

+ 分析删除多态对象的内存释放

```cpp
	Animal *animal = new Cat("Tom");
	animal->Speak();

	delete animal
```

&emsp;&emsp;基类指针指向子类对象，一般来说，调用的是基类的方法；但如果基类的方法是虚函数，则调用子类方法。所以在delete基类指针的时候，有如下两种情况：

&emsp;&emsp;1) 如果基类的析构函数**不是虚析构函数**，则调用基类的析构函数
&emsp;&emsp;2) 如果基类的析构函数**是虚析构函数**，则先调用子类的析构函数，然后调用基类的析构函数。（调用子类析构函数，释放子类new出来的空间）

#### 4.6.4 虚函数表

&emsp;&emsp;如果当前类或者基类中有virtual函数，则实例化的对象中；第一个对象是虚表指针。
&emsp;&emsp;一个类只有一个虚函数表。在编译时，一个类的虚函数表就确定了，存放在只读数据段中。

+ 普通继承

&emsp;&emsp;子类中与基类虚函数同名的函数，也会自动加上virtual。

&emsp;&emsp;首先，子类会继承基类的虚函数表（子类和基类的表不是同一个表，虚表指针没有指向同一块空间），如果重写了基类的虚函数会更新虚函数表。如果没有重写任何基类的虚函数，那么子类和基类的虚函数表是内容是一致的。

+ 多继承

&emsp;&emsp;在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。

注意：
- 1.子类虚函数会覆盖每一个父类的每一个同名虚函数。
- 2.父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。(不能调用，编译期就已经不存在)
- 3.父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用。



## 5、模板template

### 5.1 基本概念

+ 模板定义

&emsp;&emsp;模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。模版可以分为两类，一个是函数模版，另外一个是类模版。

&emsp;&emsp;通常，当我们调用一个函数/定义实例化一个类时，编译器只需掌握函数的声明/类的声明即可，因此可以把函数/类的声明放置在头文件，而把函数/类的定义放置在源文件中。但是模板则不同：为了实例化模板函数，编译器必须掌握函数模板/类模板成员函数的声明和定义，因此只能将模板函数/类的声明和定义都放置在头一个头文件/源文件中（重点）

### 5.2 模板函数

&emsp;&emsp;模板函数的原型定义

```cpp
template <class identifier> function_declaration;
template <typename identifier> function_declaration;
```

+ 例子

```cpp
template <class T>
T min(T x,T y)
{
    return(x<y)?x:y;
}

void main()
{
     int n1=2,n2=10;
     double d1=1.5,d2=5.6;
     cout<< "较小整数:"<<min(n1,n2)<<endl;
     cout<< "较小实数:"<<min(d1,d2)<<endl;
}
```

### 5.3 模板类

&emsp;&emsp;普通类里面可以有模板函数
&emsp;&emsp;类中有模板成员的类

```cpp
template<class T>
class A{
public:
    T a;
    T b;

    T hy(T c, T &d);
};

//成员函数可以在类模板的定义中定义(这样就是 inline函数)，也可以在类模板定义之外定义，如下
template<class T1,class T2>
void A<T1,T2>::h(){
}
```

### 5.4 模板特化

```cpp
// 声明类模板:
template <typename T>
class mycontainer {
    T element;
  public:
    mycontainer (T arg) {element=arg;}
    T increase () {return ++element;}
};

// int类型的模板特化:
template <>
class mycontainer<int> {
    int element;
  public:
    mycontainer(int arg) {
        element=arg;
    }

    void setZero()
    {
      element=0;
      cout<<"??"<<element<<endl;
    }
};
```

+ 注意

&emsp;&emsp;使用模板特化功能mycontainer<int> t2的时候，t2不可以使用标准模板中的方法
&emsp;&emsp;模板特化功能的<参数>可以是一个整型、一个指向对象或函数的指针（或引用）。


