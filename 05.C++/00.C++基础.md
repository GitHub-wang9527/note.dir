
## 章节目录

[TOC]

---

学习[他人的笔记](https://github.com/0voice/cpp_new_features)

## C++ 学习笔记

#### const 修饰指针

	//const修饰的是指针，指针指向可以改，指针指向的值不可以更改
	const int * p1 = &a; 

	//const修饰的是常量，指针指向不可以改，指针指向的值可以更改
	int * const p2 = &a;

    //const既修饰指针又修饰常量
	const int * const p3 = &a;
	
	
## C++核心编程

### 1 内存分区模型

#### C++程序在执行时，将内存大方向划分为4个区域

+ 代码区：存放函数体的二进制代码，由操作系统进行管理的

存放 CPU 执行的机器指令
代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令

+ 全局区：存放全局变量和静态变量以及常量

全局变量和静态变量存放在此
全局区还包含了常量区, 存放 const修饰的全局常量 和 字符串常量
该区域的数据在程序结束后由操作系统释放

+ 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等

局部常量在栈区
由编译器自动分配释放, 存放函数的参数值，局部变量等

+ 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

用new开辟的对象（手动释放）

### 2 引用

引用必须初始化
引用在初始化后，不可以改变

引用可以作为返回值


引用的本质在c++内部实现是一个指针常量，所以指向不可改
	int& ref = a 自动转换为 int* const ref = &a
	
常量引用主要用来修饰形参，防止误操作
	const int& v
	
### 3 函数提高

+ 函数占位符

占位符可以拥有默认参数，如果占位符没有写默认参数，那么调用的时候必须填写
void func2(int a,int = 1){}

+ 函数重载

void func(int &a){cout << "func (int &a) 调用 " << endl;}
void func(const int &a){cout << "func (const int &a) 调用 " << endl;}

void func2(int a, int b = 10){cout << "func2(int a, int b = 10) 调用" << endl;}
void func2(int a){cout << "func2(int a) 调用" << endl;}

	int a = 10;
	func(a); //调用无const
	func(10);//调用有const
	
	func2(10); //有歧义 报错
	
### 4 类和对象

#### C++中 struct和class唯一的区别就在于 默认的访问权限不同

#### 构造函数

+ 普通构造函数和拷贝构造函数
	
```cpp
	//普通构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
```

+ 调用普通的含参构造函数

```cpp

	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); 
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构

	//2.3 隐式转换法
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 

	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	//Person p5(p4);
```

+ 拷贝构造函数调用时机

当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数会被调用。

C++中拷贝构造函数调用时机通常有三种情况

1) 使用一个已经创建完毕的对象来初始化一个新对象，比如
```cpp
	Person man(100); //p对象已经创建完毕
	Person newman(man); //调用拷贝构造函数
	Person newman2 = man; //拷贝构造
```
2) 值传递的方式给函数参数传值
3) 以值方式返回局部对象

+ 编译器自动添加的函数

默认情况下，c++编译器至少给一个类添加3个函数

1) 默认构造函数(无参，函数体为空)
2) 默认析构函数(无参，函数体为空)
3) 默认拷贝构造函数，对属性进行值拷贝（浅拷贝）

构造函数调用规则如下：

如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造。

如果用户定义拷贝构造函数，c++不会再提供其他构造函数

+ 本类的构造函数和成员变量的构造函数 执行顺序

1) 构造的顺序是 ：先调用对象成员的构造，再调用本类构造
	如果声明成员变量的时候初始化了，也是先调用成员变量的构造
	如果声明成员变量的时候初始化了，并且构造函数初始化列表中也初始化了该成员变量，则只执行参数初始化列表中的构造。
	
2) 析构顺序与构造相反


+ 静态成员

	静态成员变量
		所有对象共享同一份数据
		在编译阶段分配内存
		类内声明，类外初始化
	静态成员函数
		所有对象共享同一个函数
		静态成员函数只能访问静态成员变量
		
#### C++对象模型和this指针	
	
##### 成员变量和成员函数分开存储

	类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上	

	//非静态成员变量占对象空间
	//静态成员变量不占对象空间
	//函数也不占对象空间，所有函数共享一个函数实例
	//静态成员函数也不占对象空间	

##### this指针

我们知道在C++中成员变量和成员函数是分开存储的。每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？

c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**。

+ this指针的用途：
	当形参和成员变量同名时，可用this指针来区分
	在类的非静态成员函数中返回对象本身，可使用return *this

+ 空指针访问成员函数
	
```cpp
Person *p=nullprt;
p->country()		// 如果country方法中没有使用this，函数可以正常运行
```

	在类中使用成员变量和成员函数，可以不加this；编译器在展开时，自动添加this
	

+ const修饰成员函数

常函数：

	成员函数后加const后我们称为这个函数为常函数
	常函数内不可以修改成员属性
	成员属性声明时加关键字mutable后，在常函数中依然可以修改
	
常对象：

	声明对象前加const称该对象为常对象
	常对象只能调用常函数

#### 友元

友元的目的就是让一个函数或者类 访问另一个类中私有成员

1) 全局函数做友元
2) 类做友元
3) 成员函数做友元

+ 注意

&emsp;&emsp;友元关系不能被继承。 
&emsp;&emsp;友元关系是单向的，不具有交换性
&emsp;&emsp;友元关系不具有传递性。


#### 运算符重载

	见其它文件

#### 继承

+ 继承和访问权限
	public继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, private
	protected继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, private
	private继承：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, private
	
	

注意：子类继承父类时，也将父类私有成员变量继承了过来，只是对子类不可见，不可操作。

+ 抽象类和纯虚函数

	纯虚函数，语法：virtual 返回值类型 函数名 （参数列表）= 0 ;
	抽象类：子类包含抽象类中的纯虚函数
	抽象类不可以实例化

+ 多态和虚析构函数

	释放多态对象的时候
		1) 如果基类的析构函数不是虚析构函数，则调用基类的析构函数
		2) 如果基类的析构函数是虚析构函数，则先调用子类的析构函数，然后调用基类的析构函数
	Animal *animal = new Cat("Tom");
	animal->Speak();

	//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏
	//怎么解决？给基类增加一个虚析构函数
	//虚析构函数就是用来解决通过父类指针释放子类对象
	delete animal;

## 5 文件操作

	略

## 阅读END


### 模板template

#### 基本概念

+ 模板定义

模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。模版可以分为两类，一个是函数模版，另外一个是类模版。

+ 模板的参数

　　1）一般来说，非类型模板参数可以是常整数（包括枚举）或者指向外部链接对象的指针。  
　　那么就是说，浮点数是不行的，指向内部链接对象的指针是不行的。

　　2）模板类型是一个容器或类

#### 模板函数

模板函数的原型定义

```cpp
template <class identifier> function_declaration;
template <typename identifier> function_declaration;
```

例子

```cpp
template <class T>
T min(T x,T y)
{ 
    return(x<y)?x:y;
}

void main()
{
     int n1=2,n2=10;
     double d1=1.5,d2=5.6;
     cout<< "较小整数:"<<min(n1,n2)<<endl;
     cout<< "较小实数:"<<min(d1,d2)<<endl;
}
```

#### 模板类

普通类里面可以有模板函数
类中有模板成员的类

```cpp
template<class T>
class A{
public: 
    T a;
    T b; 
    
    T hy(T c, T &d);
};

//成员函数可以在类模板的定义中定义(这样就是 inline函数)，也可以在类模板定义之外定义，如下
template<class T1,class T2>
void A<T1,T2>::h(){
}
```

#### 模板特化



```cpp
// 声明类模板:
template <typename T>
class mycontainer {
    T element;
  public:
    mycontainer (T arg) {element=arg;}
    T increase () {return ++element;}
};

// int类型的模板特化:
template <>
class mycontainer<int> {
    int element;
  public:
    mycontainer(int arg) {
        element=arg;
    }

    void setZero()
    {
      element=0;
      cout<<"??"<<element<<endl;
    }
};
```

注意：使用模板特化功能mycontainer<int> t2的时候，t2不可以使用标准模板中的方法















	
