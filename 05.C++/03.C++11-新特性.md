
## 章节目录

[TOC]

## nullptr

### C里面的NULL

在C语言中，NULL通常被定义为：#define NULL ((void *)0)

所以说NULL实际上是一个空指针，如果在C语言中写入以下代码，编译是没有问题的，因为在C语言中把空指针赋给int和char指针的时候，**发生了隐式类型转换**，把void指针转换成了相应类型的指针。

```cpp
int  *pi = NULL;
char *pc = NULL;
```
### C++程序中的NULL

在C++中，NULL通常被定义为：#define NULL 0
为什么C++在NULL的定义上不继续兼容C延续(void*)0的定义呢？因为C++中不能将void*类型的指针隐式转换成其他指针类型。使用char *pc = NULL;会报错。

但是问题来了，下面代码如果使用C++编译器来编译则是会出错的，test(NULL)有二义性。

```cpp
void test(void *p)
{
    cout<<"p is pointer "<<p<<endl;
 }
void test(int num)
{
    cout<<"num is int "<<num<<endl; 
}
int main(void)
{
    test(NULL); 						// error
    test(0);							// ok                
    return 0; 
}
```

有些环境上，#define NULL __null，__null是编译器相关的行为(要么是常量0，要么是 (void *)0)，有待进一步研究确认。
所以test(NULL) 会产生二义性。

## 类型推导

### auto

auto不可以用于函数传参
```cpp
// 编译 error
int add(auto x, auto y);
```
auto也不能用于推导数组类型

### decltype

	略

## 区间迭代 for循环

for(auto &i : arr) { }

+ 和foreach的区别

&emsp;&emsp;foreach()遍历的实际上是副本，所以遍历的过程中不可以修改元素，但可以删除元素
&emsp;&emsp;for(auto e :): 遍历过程中不可以删除元素

## 模板增强

### 外部模板

传统 C++ 中，模板只有在使用时才会被编译器实例化。只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。

C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化：

```cpp
template class std::vector<bool>;            // 强行实例化
extern template class std::vector<double>;  // 不在该编译文件中实例化模板
```

### 尖括号 “>”

在传统 C++ 的编译器中，>>一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码：

```cpp
std::vector<std::vector<int>> wow;
```

这在传统C编译器下是不能够被编译的，而 C11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。

## 构造函数

### 委托构造

C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：

**额 之前用过**

```cpp
class Base {
public:
    int value1;
    int value2;
    Base() {
        value1 = 1;
    }
    Base(int value) : Base() {  // 委托 Base() 构造函数
        value2 = 2;
    }
};
```

### 继承构造

在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。
假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。如下：

```cpp
struct A
{
  A(int i) {}
  A(double d,int i){}
  A(float f,int i,const char* c){}
  //...等等系列的构造函数版本
}；
struct B:A
{
  B(int i):A(i){}
  B(double d,int i):A(d,i){}
  B(folat f,int i,const char* c):A(f,i,e){}
  //......等等好多个和基类构造函数对应的构造函数
}；
```

C++11的继承构造：

```cpp
struct A
{
  A(int i) {}
  A(double d,int i){}
  A(float f,int i,const char* c){}
  //...等等系列的构造函数版本
}；
struct B:A
{
  using A::A;
  //关于基类各构造函数的继承一句话搞定
  //......
}；
```

如果一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。

## 新增容器 略

### std::array
### std::forward_list
### 无序容器
	std::unordered_map/std::unordered_multimap和 std::unordered_set/std::unordered_multiset
### 元组 std::tuple

## 正则表达式 略

## lambda  见Qt

## std::function TODO

	类模版std::function是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。

## 右值引用和move语义

	右值引用 即 所有权转移




























## 关键字

### override关键字（C++11）

#### 作用：

&emsp;&emsp;1.在函数比较多的情况下可以提示读者某个函数重写了基类虚函数（表示这个虚函数是从基类继承，不是派生类自己定义的）；  
&emsp;&emsp;2.强制编译器检查某个函数是否重写基类虚函数，如果没有则报错。

#### 用法：

在函数声明后添加  

```cpp
QStringList getMember() override ;
```

### explicit关键字

&emsp;&emsp;[只对构造函数起作用，用来抑制隐式转换](https://blog.csdn.net/zhenghongzhi6/article/details/7372047)
