
## 章节目录

[TOC]

## nullptr

### C里面的NULL

在C语言中，NULL通常被定义为：#define NULL ((void *)0)

所以说NULL实际上是一个空指针，如果在C语言中写入以下代码，编译是没有问题的，因为在C语言中把空指针赋给int和char指针的时候，**发生了隐式类型转换**，把void指针转换成了相应类型的指针。

```cpp
int  *pi = NULL;
char *pc = NULL;
```
### C++程序中的NULL

在C++中，NULL通常被定义为：#define NULL 0
为什么C++在NULL的定义上不继续兼容C延续(void*)0的定义呢？因为C++中不能将void*类型的指针隐式转换成其他指针类型。使用char *pc = NULL;会报错。

但是问题来了，下面代码如果使用C++编译器来编译则是会出错的，test(NULL)有二义性。

```cpp
void test(void *p)
{
    cout<<"p is pointer "<<p<<endl;
 }
void test(int num)
{
    cout<<"num is int "<<num<<endl; 
}
int main(void)
{
    test(NULL); 						// error
    test(0);							// ok                
    return 0; 
}
```

有些环境上，#define NULL __null，__null是编译器相关的行为(要么是常量0，要么是 (void *)0)，有待进一步研究确认。
所以test(NULL) 会产生二义性。

## 类型推导

### auto

auto不可以用于函数传参
```cpp
// 编译 error
int add(auto x, auto y);
```
auto也不能用于推导数组类型

### decltype

	略

## 区间迭代 for循环

for(auto &i : arr) { }

+ 和foreach的区别

&emsp;&emsp;foreach()遍历的实际上是副本，所以遍历的过程中不可以修改元素，但可以删除元素
&emsp;&emsp;for(auto e :): 遍历过程中不可以删除元素

## 模板增强

### 外部模板

传统 C++ 中，模板只有在使用时才会被编译器实例化。只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板实例化。

C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使得能够显式的告诉编译器何时进行模板的实例化：

```cpp
template class std::vector<bool>;            // 强行实例化
extern template class std::vector<double>;  // 不在该编译文件中实例化模板
```

### 尖括号 “>”

在传统 C++ 的编译器中，>>一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码：

```cpp
std::vector<std::vector<int>> wow;
```

这在传统C编译器下是不能够被编译的，而 C11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。

## 构造函数

### 委托构造

C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：

**额 之前用过**

```cpp
class Base {
public:
    int value1;
    int value2;
    Base() {
        value1 = 1;
    }
    Base(int value) : Base() {  // 委托 Base() 构造函数
        value2 = 2;
    }
};
```

### 继承构造

在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。
假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。如下：

```cpp
struct A
{
  A(int i) {}
  A(double d,int i){}
  A(float f,int i,const char* c){}
  //...等等系列的构造函数版本
}；
struct B:A
{
  B(int i):A(i){}
  B(double d,int i):A(d,i){}
  B(folat f,int i,const char* c):A(f,i,e){}
  //......等等好多个和基类构造函数对应的构造函数
}；
```

C++11的继承构造：

```cpp
struct A
{
  A(int i) {}
  A(double d,int i){}
  A(float f,int i,const char* c){}
  //...等等系列的构造函数版本
}；
struct B:A
{
  using A::A;
  //关于基类各构造函数的继承一句话搞定
  //......
}；
```

如果一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。

## 新增容器 略

### std::array
### std::forward_list
### 无序容器
	std::unordered_map/std::unordered_multimap和 std::unordered_set/std::unordered_multiset
### 元组 std::tuple

## 正则表达式 略

## std::function TODO

	类模版std::function是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。

## 左值右值

	C++ 11，编译器会依据参数是左值还是右值在复制构造函数和转移构造函数间进行选择
	c=a+b		转移构造函数
	c=a			复制构造函数
	
### 右值引用

	右值引用 即 所有权转移
    string && abc = string("hello ")+ string("world");

+ 返回值优化

    g++ 内置了返回值优化的功能

```cpp
A test()
{
    return A();
}
A a=test();
```
编译器会将test函数里A的构造过程直接运用在a上，不会先生成一个零时变量，然后调用拷贝构造函数，赋值给a。

### 转移左值

    使用std::move(p)后，编译器将左值p当做右值看待。


## Lambda 表达式

Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。

### 基本语法

```cpp
[ caputrue ] ( params ) opt -> ret { body; };
```

- capture是捕获列表；
- params是参数表；(选填)
- opt是函数选项；可以填mutable,exception,attribute（选填）
 - mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。
 - exception说明lambda表达式是否抛出异常以及何种异常。
 - attribute用来声明属性。

### capture捕获列表

[]不捕获任何变量。
[&]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。
[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意值捕获的前提是变量可以拷贝，且**被捕获的量在 lambda 表达式被创建时拷贝，而非调用时才拷贝**。如果希望lambda表达式在调用时能即时访问外部变量，我们应当用引用方式捕获。

+ 举例

[=,&foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。

[bar]按值捕获bar变量，同时不捕获其他变量。

[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。

+ [=]值捕获，却无法修改变量

```cpp
int a = 0;
auto f1 = [=] { return a++; };                //error
auto f2 = [=] () mutable { return a++; };       //OK
```

虽然按值捕获的变量值均复制一份存储在lambda表达式变量中，修改他们也并不会真正影响到外部，但我们却仍然无法修改它们。如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为mutable。被mutable修饰的lambda表达式就算没有参数也要写明参数列表。

原因：lambda表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终会变为闭包类型的成员变量。按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量的值的。而mutable的作用，就在于取消operator()的const。

### lambda表达式的大致原理：

每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值。

#### 悬挂引用

[&]捕获的变量的生命周期已经结束，[=]捕获的是指针变量，但指向的对象可能已经被释放


## 关键字

### final & override（C++11）

&emsp;&emsp;final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载。
&emsp;&emsp;override表示这个虚函数是从基类继承，不是派生类自己定义的。编译器会强制检查。

### default & delete

+ default

	编译器将为显式声明的 "=default"函数自动生成函数体。 
	"=default"函数特性仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。
```cpp
X() = default; //该函数比用户自己定义的默认构造函数获得更高的代码效率
```

+ delete

    只需在函数声明后上“=delete;”，就可将该函数禁用。
    
```cpp
class X3
{
public:
    X3();
    X3(const X3&) = delete;  // 声明拷贝构造函数为 deleted 函数
    X3& operator = (const X3 &) = delete; // 声明拷贝赋值操作符为 deleted 函数
};

// "=delete"函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换
class X4
{
public:
    X4(double){}
    X4(int) = delete;
};

// "=delete"函数特性还可以用来禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象
class X5
{
public:
    void *operator new(size_t) = delete;
    void *operator new[](size_t) = delete;
};
```

### explicit

    explicit关键字只需用于类内的单参数构造函数前面。
    由于无参数的构造函数和多参数的构造函数总是显示调用，不存在隐式转换。

#### 什么是隐式转换

	A a5 = 1; // 先隐式转换，再复制初始化
	
### const &  constexpr（C++11）

const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来


### enum class

不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，这都是潜在的难以调试的bug，可以通过有作用域的枚举来规避。例子如下：

```cpp
enum class AColor{}
enum class BColor{}
AColor::kRed == BColor::kWhite  // 编译失败
```

### assertion

```cpp
static_assert(true/false, message);
```

c++11引入static_assert声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。

## 自定义字面量

```cpp
std::this_thread::sleep_for(100ms); // c++14里可以这么使用，这里只是举个自定义字面量使用的例子
```

## 内存对齐

C++11新增了一些函数，用于内存对象

```cpp
    static std::aligned_storage<sizeof(A),
    alignof(A)>::type data;
    A *attr = new (&data) A;
```

## thread_local

c++11引入thread_local，用thread_local修饰的变量具有thread周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。

```cpp
#include <iostream>
#include <thread>

class A {
    public:
    A() {}
    ~A() {}

    void test(const std::string &name) {
        thread_local int count = 0;
        ++count;
        std::cout << name << ": " << count << std::endl;
    }
};

void func(const std::string &name) {
    A a1;
    a1.test(name);
    a1.test(name);
    A a2;
    a2.test(name);
    a2.test(name);
}

int main() {
    std::thread(func, "thread1").join();
    std::thread(func, "thread2").join();
    return 0;
}
```

注意，在linux上，CMakeLists.txt需要添加如下内容，否则会报错

```cpp
#查找依赖库
find_package(Threads REQUIRED)

#引入依赖库
target_link_libraries(${CMAKE_PROJECT_NAME} Threads::Threads)
```

输出

```cpp
thread1: 1
thread1: 2
thread1: 3
thread1: 4
thread2: 1
thread2: 2
thread2: 3
thread2: 4
```

可以看出：线程私有变量，一个线程拥有且只拥有一个该实例，类似于static


## 新增数据结构

std::forward_list：单向链表，只可以前进，在特定场景下使用，相比于std::list节省了内存
std::unordered_set：基于hash表实现的set，内部不会排序，使用方法和set类似
std::unordered_map：基于hash表实现的map，内部不会排序，使用方法和set类似
std::array：数组，在越界访问时抛出异常，建议使用std::array替代普通的数组
std::tuple：元组类型，类似pair，但比pair扩展性好

## 新增算法

- all_of：检测表达式是否对范围[first, last)中所有元素都返回true，如果都满足，则返回true
```cpp
std::vector<int> v(10, 2);
if (std::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; })) {
    std::cout << "All numbers are even\n";
}
```

- any_of：检测表达式是否对范围[first, last)中至少一个元素返回true，如果满足，则返回true，否则返回false，用法和上面一样

- none_of：检测表达式是否对范围[first, last)中所有元素都不返回true，如果都不满足，则返回true，否则返回false，用法和上面一样

- find_if_not：找到第一个不符合要求的元素迭代器，和find_if相反

- copy_if：复制满足条件的元素

- itoa：对容器内的元素按序递增

```cpp
std::vector<int> l(10);
std::iota(l.begin(), l.end(), 19); // 19为初始值
for (auto n : l) std::cout << n << ' ';
// 19 20 21 22 23 24 25 26 27 28
```

- minmax_element：返回容器内最大元素和最小元素位置

```cpp
int main() {
    std::vector<int> v = {3, 9, 1, 4, 2, 5, 9};

    auto result = std::minmax_element(v.begin(), v.end());
    std::cout << "min element at: " << *(result.first) << '\n';
    std::cout << "max element at: " << *(result.second) << '\n';
    return 0;
}
// min element at: 1
// max element at: 9
```

- is_sorted、is_sorted_until：返回容器内元素是否已经排好序。

## 返回值优化

返回值优化(RVO)是一种C++编译优化技术










