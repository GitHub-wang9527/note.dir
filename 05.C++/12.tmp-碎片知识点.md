
## 章节目录

[TOC]

## C++的静态成员

> * 全局变量、静态全局变量、静态局部变量都是在静态存储区（全局数据区）中分配空间的，而局部变量是在栈上分配空间的。

&emsp;&emsp;C++的静态成员是属于整个类的而不是某个具体的对象。保证多个对象之间的数据共享并且不会破坏隐藏的规则。
&emsp;&emsp;静态成员函数不可以使用非静态成员。
&emsp;&emsp;静态成员变量使用前必须初始化


## 多态（基类指针指向子类对象） 

&emsp;&emsp;一般来说，调用的是基类的方法；但如果基类的方法是虚函数， 则调用子类方法。

## foreach和for(auto e :)

&emsp;&emsp;foreach()遍历的实际上是副本，所以遍历的过程中不可以修改元素，但可以删除元素
&emsp;&emsp;for(auto e :): 遍历过程中不可以删除元素


## 类图的符号

　　继承：——▷
　　接口：- - - ▷
　　有一个：——>

## C++参数初始化列表

1、举例：foo(string s, int i):name(s), id(i){} ; // 初始化列表
　　即将字符串s的值赋给name。
2、默认构造函数：没有参数或参数有默认值的构造函数
　　class();或class(int age=12,name="xiao ming");
3、必须使用参数初始化列表的情况
　　初始化引用成员
　　初始化const变量
　　初始化没有默认构造函数的类成员，包括基类没有默认构造函数

## 运算符重载

### 重载 '-'

```cpp
#include <QCoreApplication>

#include<iostream>

using namespace std;

class Time
{
public:
    Time(int h, int min)
    {
        this->h=h;
        this->min=min;
    }
    ~Time(){}
    int h;
    int min;

    //在类的内部进行运算符重载
    Time operator-(const Time &t)const
    {
        Time sub(0,0);
        sub.h = h - t.h;
        sub.min = min - t.min;
        return sub;
    }
};

int main(int argc, char* argv[])
{
    Time t1(1, 1);
    Time t2(2, 0);
    Time t = t1- t2;

    cout << t.h <<", "<<t.min<<endl;
    return 0;
}
```

输出

```cpp
    -1, 1
```

### 重载 '()'

```cpp
#include<iostream>

using namespace std;

class cls
{
public:
    cls()
    {
        printf("构造函数\n");
    }
    void operator() ()  //重载"()"操作符，"()"内无操作数
    {
        printf("HelloWorld!\n");
    }

    void operator() (const char* str) //重载"()"，"()"内的操作数是字符串
    {
        printf("%s", str);
    }
};

int main(void)
{
    cls cc;
    cc();
    cc("Hello Linux\n");
    return 0;
}
```

输出

```cpp
    构造函数
    HelloWorld!
    Hello Linux
```

## 智能指针

```cpp
#include <memory>
```

1、前置知识：
　　1）定义一个对象，其作用域为{}之间；当大括号结束时，程序调用类的析构函数。
　　2）定义的是类指针，即p=new className();时。需要手动调用delete p;来释放空间。
　　3）但有时程序执行不到delete语句，所以引用智能指针的概念。

2、作用只要智能指针变量一退出作用域时，引用计数的值减为0；然后就会就会调用析构函数， 析构之前的对象。

3、智能指针的策略
　　建立所有权（ownership）概念。对于特定的对象，同一时刻只能有一个智能指针可拥有， 比如说当智能指针A指向对象x，当执行完B=A后，原来的指针A就失去了对x的所有权，这样只有拥有对象的智能指针的构造函数会删除该对象，unique_ptr和auto_ptr就是采用这种策略。
　　创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。

4、auto_ptr：C++11已弃用
5、unique_ptr：
　　与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，在编译时就将可能潜在的错误暴露出来。
```cpp
unique_ptr<int> py;
py=px;
cout<<"*px = "<<*px<<endl;//error,py = px使得对象的所有权从px转让给py了，px已经变为空指针了。
```
6、shared_ptr：
```cpp
shared_ptr<int> px(new int()8);
shared_ptr<int> py;
py=px;
cout<<"*px = "<<*px<<endl;//使用shared_ptr时运行正常，因为shared_ptr采用引用计数，当执行完赋值语句py = px后，px和py都指向同一块内存，
//只不过在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。
```

7、weak_ptr：  
    [TODO 继续学习1](https://blog.csdn.net/hp_truth/article/details/40511617)  
    [TODO 继续学习2](https://mp.weixin.qq.com/s/fM9fM1UhLhFWHJyKhFyhrg)
