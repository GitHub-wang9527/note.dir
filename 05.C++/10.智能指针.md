# 智能指针

标签（空格分隔）： C++

---
```cpp
#include <memory>
```

1、前置知识：
　　1）定义一个对象，其作用域为{}之间；当大括号结束时，程序调用类的析构函数。
　　2）定义的是类指针，即p=new className();时。需要手动调用delete p;来释放空间。
　　3）但有时程序执行不到delete语句，所以引用智能指针的概念。

2、作用只要智能指针变量一退出作用域时，引用计数的值减为0；然后就会就会调用析构函数， 析构之前的对象。

3、智能指针的策略
　　建立所有权（ownership）概念。对于特定的对象，同一时刻只能有一个智能指针可拥有， 比如说当智能指针A指向对象x，当执行完B=A后，原来的指针A就失去了对x的所有权，这样只有拥有对象的智能指针的构造函数会删除该对象，unique_ptr和auto_ptr就是采用这种策略。
　　创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。

4、auto_ptr：C++11已弃用
5、unique_ptr：
　　与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，在编译时就将可能潜在的错误暴露出来。
```cpp
unique_ptr<int> py;
py=px;
cout<<"*px = "<<*px<<endl;//error,py = px使得对象的所有权从px转让给py了，px已经变为空指针了。
```
6、shared_ptr：
```cpp
shared_ptr<int> px(new int()8);
shared_ptr<int> py;
py=px;
cout<<"*px = "<<*px<<endl;//使用shared_ptr时运行正常，因为shared_ptr采用引用计数，当执行完赋值语句py = px后，px和py都指向同一块内存，
//只不过在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。
```

7、weak_ptr：  
    [TODO 继续学习1](https://blog.csdn.net/hp_truth/article/details/40511617)  
    [TODO 继续学习2](https://mp.weixin.qq.com/s/fM9fM1UhLhFWHJyKhFyhrg)