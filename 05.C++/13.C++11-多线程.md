## 线程相关知识点

### std::thread

```cpp
// 创建线程  20是func1的参数
std::thread tt(func1, 20);

tt.join()       // 阻塞主线程
tt.detach()     // 非阻塞
```

&emsp;&emsp;假如线程函数执行时间较长，并且没有调用joion和detach；在线程对象的生命周期结束，释放资源的时候可能会发生未知错误。

```cpp
std::thread t(func);
cout << t.get_id() << endl;                                     // 当前线程ID
cout << std::thread::hardware_concurrency() << endl;            // 当前cpu个数
auto handle = t.native_handle();                                // handle可用于pthread相关操作
std::this_thread::sleep_for(std::chrono::seconds(1));           // 睡眠
```

### std::mutex

&emsp;&emsp;```std::mutex```：独占的互斥量，不能递归使用，不带超时功能  
&emsp;&emsp;```std::recursive_mutex```：递归互斥量，可重入，不带超时功能  
&emsp;&emsp;```std::timed_mutex```：带超时的互斥量，不能递归  
&emsp;&emsp;```std::recursive_timed_mutex```：带超时的互斥量，可以递归使用

### std::atomic 原子类型

### std::call_once

&emsp;&emsp;保证某一函数在多线程环境中只调用一次

### thread_local

&emsp;&emsp;c++11引入thread_local，用thread_local修饰的变量具有thread周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。

```cpp
#include <iostream>
#include <thread>

class A {
    public:
    A() {}
    ~A() {}

    void test(const std::string &name) {
        thread_local int count = 0;
        ++count;
        std::cout << name << ": " << count << std::endl;
    }
};

void func(const std::string &name) {
    A a1;
    a1.test(name);
    a1.test(name);
    A a2;
    a2.test(name);
    a2.test(name);
}

int main() {
    std::thread(func, "thread1").join();
    std::thread(func, "thread2").join();
    return 0;
}
```

&emsp;&emsp;注意，在linux上，CMakeLists.txt需要添加如下内容，否则会报错

```cpp
#查找依赖库
find_package(Threads REQUIRED)

#引入依赖库
target_link_libraries(${CMAKE_PROJECT_NAME} Threads::Threads)
```

输出

```cpp
thread1: 1
thread1: 2
thread1: 3
thread1: 4
thread2: 1
thread2: 2
thread2: 3
thread2: 4
```

&emsp;&emsp;可以看出：线程私有变量，一个线程拥有且只拥有一个该实例，类似于static

## 新增数据结构

&emsp;&emsp;```std::forward_list```：单向链表，只可以前进，在特定场景下使用，相比于std::list节省了内存
&emsp;&emsp;```std::unordered_set```：基于hash表实现的set，内部不会排序，使用方法和set类似
&emsp;&emsp;```std::unordered_map```：基于hash表实现的map，内部不会排序，使用方法和set类似
&emsp;&emsp;```std::array```：数组，在越界访问时抛出异常，建议使用std::array替代普通的数组
&emsp;&emsp;```std::tuple```：元组类型，类似pair，但比pair扩展性好

## 新增算法

+ all_of：检测表达式是否对范围[first, last)中所有元素都返回true，如果都满足，则返回true

```cpp
std::vector<int> v(10, 2);
if (std::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; })) {
    std::cout << "All numbers are even\n";
}
```

+ any_of：检测表达式是否对范围[first, last)中至少一个元素返回true，如果满足，则返回true，否则返回false，用法和上面一样

+ none_of：检测表达式是否对范围[first, last)中所有元素都不返回true，如果都不满足，则返回true，否则返回false，用法和上面一样

+ find_if_not：找到第一个不符合要求的元素迭代器，和find_if相反

+ copy_if：复制满足条件的元素

+ itoa：对容器内的元素按序递增

```cpp
std::vector<int> l(10);
std::iota(l.begin(), l.end(), 19); // 19为初始值
for (auto n : l) std::cout << n << ' ';
// 19 20 21 22 23 24 25 26 27 28
```

+ minmax_element：返回容器内最大元素和最小元素位置

```cpp
int main() {
    std::vector<int> v = {3, 9, 1, 4, 2, 5, 9};

    auto result = std::minmax_element(v.begin(), v.end());
    std::cout << "min element at: " << *(result.first) << '\n';
    std::cout << "max element at: " << *(result.second) << '\n';
    return 0;
}
// min element at: 1
// max element at: 9
```

+ is_sorted、is_sorted_until：返回容器内元素是否已经排好序。
