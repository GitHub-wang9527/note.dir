
### 章节目录

[TOC]

---

## 2、阻塞IO模型

&emsp;&emsp;进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程，操作成功则进程获取到数据。

## 3、非阻塞IO模型

&emsp;&emsp;和上面的阻塞IO模型相比，非阻塞IO模型在内核数据没准备好，需要进程阻塞的时候，就返回一个错误，以使得进程不被阻塞。

&emsp;&emsp;进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞。进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。

&emsp;&emsp;这种工作方式下需要不断轮询查看状态

## 4、IO复用模型

&emsp;&emsp;多个的进程的IO可以注册到一个复用器(select)上，然后用一个进程调用该select,，select会监听所有注册进来的IO。

&emsp;&emsp;如果select监听的IO在内核缓冲区都没有可读数据，**调用select的进程会被阻塞**；而当任一IO在内核缓冲区中有可读数据时，select调用就会返回；而后select调用进程可以继续运行。  
&emsp;&emsp;从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。**和go的select语句**一样。

Linux中IO复用的实现方式主要有Select，Poll和Epoll：

- Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_ SIZE（1024）。
- Poll：原理和Select相似，没有数量限制，但IO数量大，扫描线性性能下降。
- Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持。

## 5、信号驱动IO模型

&emsp;&emsp;当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。

## 6、异步IO模型

&emsp;&emsp;当进程发起一个IO操作，进程返回(不阻塞)，但也不能返回结果。内核把整个IO处理完后，会通知进程结果，如果IO操作成功则进程直接获取到数据。  
&emsp;&emsp;和之前几个模型最大的区别是，内核准备好数据后，将数据拷贝到用户空间；然后通知用户态进程。
