
## 一、Qt容器介绍

> QTL比起STL的话，最大的特点是统一用了写时复制技术。

### 1. 写时拷贝和隐式共享

采用隐式共享计数，将深拷贝和浅拷贝结合起来。
数据中存放了指向数据的指针和共享计数；
拷贝构造函数使用的是浅拷贝，并且共享计数+1；
修改数据的时候，如果当前的共享计数大于1，则进行一次深拷贝；并将原本的共享计数-1；

有此特性的包括：所有容器类，QString，QByteArray、QBrush、QPen、QPalette、QBitmap、QImage、QPixmap、QCursor、QDir、QFont和QVariant等。

### 2. 和stl中容器的简单类比

- QLinkedList —— std::list 两者都是双向链表，两者可以直接互转。
- QVector —— std::vector 两者都是动态数组，都是根据sizeof(T)进行连续分配，保证成员内存连续，能够用data()直接取出指针作为c数组使用，两者可以直接互转。
- QMap —— std::map 两者都是红黑树算法，但不能互转，因为数据成员实现方式不同。std::map的数据成员用的是std::pair，而QMap用的是自己封装的Node，当然还是键值对.
- QMultiMap —— std::multimap 同上。
- QList —— 暂无。QList其实不是链表，是优化过的vector，官方的形容是array list。它的存储方式是分配连续的node，每个node的数据成员不大于一个指针大小，所以对于int、char等基础类型，它是直接存储，对于Class、Struct等类型，它是存储对象指针。
和std::deque很相似，但有少许区别。据有的知友提出，QList更像是boost::deque。
QList虽然是个特殊的Vector，但提供的接口仍然是和std::list的互转

- QBitArray —— std::bitset 功能相同，实现相似，都是构造一个array，用位操作来存取数据。不同的是，QBitArray数据的基础元素是unsigned char，而bitset是unsigned long。所以QBitArray可能在空间消耗上会省一点。至于效率上么，二者查询都是一次寻址提取加一次移位操作，算法层面应该没有区别。
　　不过二者最大的差别是，std::bitset是定长，数据元素分配在栈上。QBitArray是变长，数据元素分配在堆上。这个肯定有性能差别。

- QHash —— std::unordered_map都是各自实现了自己的hashTable，然后查询上都是用node->next的方式逐一对比，不支持互转，性能上更多的应该是看hash算法。QHash为常用的qt数据类型都提供好了qHash()函数，用户自定类型也能通过自己实现qHash()来存入QHash容器。
- QSet —— std::unordered_set二者不能互转，实现方式本质相同，都是改造过的QHash，用key来存数据，value置空。另外STL提供了使用红黑树的std::set，可以看作是std::map的改造版。std::unordered_set效率上一般应该是和QSet没区别，std::set效率较低，但不用担心撞车。
- QVarLengthArray —— std::array std::array是用class封装后的定长数组，数据分配在栈上。QVarLengthArray类似，默认也是定长数组，栈分配。但用户依旧可以添加超出大小的内容，此时它会退化为Vector，改用堆分配。

## 二、具体的容器类

### 1. QList

QList的实现模式，优点主要在于快速插入。因为其元素大小不会超过sizeof(void*)，所以插入时只需要移动指针，而非如vector那样移动对象。并且，由于QList存储的是void*，所以可以简单粗暴的直接用realloc()来扩容。

另外，QList的增长策略是双向增长（TODO数组如何双向增长？），所以对prepend支持比vector好得多，使用灵活性高于Vector和LinkedList。缺点是每次存入对象时，需要构造Node对象，带来额外的堆开销。


在Qt里，QList是官方最常用的容器类，也是官方最推荐的

它的存储方式是分配连续的node，每个node的数据成员不大于一个指针大小，所以对于int、char等基础类型，它是直接存储，对于Class、Struct等类型，它是存储对象指针。

实际QList的内存浪费很严重——当元素小于等于sizeof(void*)时，会直接存储元素，但按照void*对齐的话，过小的数据类型会浪费内存。
当元素大于sizeof(void*)时，存在分配指针的开销。
但是，当元素是moveable类型（有构造函数但可以直接memcpy），且大小等于sizeof(void*)时，QList在内存开销和性能两者上都达到了完美。
Qt的许多常用数据类型刚好满足这个条件（Qt内建类型习惯用QXxxPrivate指针存储对象数据），包括但不限于QString、QByteArray、QIcon、QFileInfo、QPen、QUrl……

QList<T>表示为一组指向被存储元素的数组。（例外，如果T本身就是指针类型，或者是size不大于指针类型的基本类型，或者是Qt的共享类，那么QList<T>会直接在指针数组中存储这些元素。）元素个数小于1000的QList能够很快地实现在链表中间插入操作，以及快速的查找操作。此外，由于QList在链表两端都预先分配了内存，因此实现prepend()和append()操作都很快。注意：对于size比指针大的共享类，使用QVector会更好。

+ 证明QList的存储方式

```cpp
    QList<int> list;
    QVector<int> vector;

    for(int i=0;i<3;++i){
        QDate d=QDate::currentDate();
        list<<1;
        vector<<1;
    }
    qDebug()<<sizeof(QDate);
    qDebug()<<sizeof(list);
    qDebug()<<sizeof(vector);

    for(int i=0;i<3;++i){
        qDebug()<<&list[i];
    }
    for(int i=0;i<3;++i){
        qDebug()<<&vector[i];
    }
```


### 2. QMap

QMap中的键值对根据key进行了排序，QMap中的key类型必须重载'<'。

+ 遍历的过程中删除
```cpp
    QMap<int,int> map;
    QMap<int,int>::iterator itor=map.begin();
    while (itor!=map.end())
    {
        bool isRemove;
        if (isRemove){
            itor = map.erase(itor);
        }
        else {
            ++itor;
        }
    }
```

 当map中不包含key（key==4）的时候，map.value(4)和map[4]都会返回一个value，前者的map.size()不变，后者会加一

#### 2.1 和QHash的对比

QHash的查找速度明显快于QMap
QHash占用的存储空间明显多于QMap
QHash以任意的方式存储元素
QMap以Key顺序存储元素
QHash的键类型必须提供operator==()和qHash(key)函数
QMap的键类型必须提供operator<()函数

### QString

0~20字节，每次分配4个字符空间。
20~4084，分配的内存块大小以2倍的速度增长。
大于4084，每次以2048个字符大小（4096字节，即4KB）的步长增长。












