
原文链接：https://blog.csdn.net/qinpanke/article/details/51705283
```cpp
#include <QObject>
#include <QRunnable>
#include <QThread>
#include <QThreadPool>
#include <QDebug>

#include <QCoreApplication>

/*

在程序运行过程中，我们观察发现程序的进程一直仅占用约1MB的内存空间。如果在main函数中所创建的100个HelloWorldTask 指针对象没有被QThreadPool释放的话，随着程序的运行该程序所占内存空间应该逐步攀升到约100MB。然而实际情况是，该程序最高仅占用1MB的内存空间。

综上两个方面可以得出以下结论：QRunnable创建的对象QThreadPool在执行完该对象后会帮助我们来清空内存，不需要我们手动回收内存。


*/

class HelloWorldTask : public QRunnable
{
public:
	void run()
	{
		for (int nCount = 0; nCount < 5; nCount++)
		{
// 			QString threadText = QStringLiteral("@0x%1").arg(quintptr(QThread::currentThreadId()), 16, 16, QLatin1Char('0'));
			/*
				qDebug() << quintptr(QThread::currentThreadId()), 16, 16, QLatin1Char('0')并不是我想像中的线程id；
				虽然，在我单独使用QThread的使用，上一行代码的输出和vs调试时的线程id一样。
				
				猜测：线程池中的线程时反复使用的；当前线程（QRunnable）运行结束。移除当前QRunnable，并将下一个QRunnable移入线程池；
				线程池中的没有变化，所以打印的quintptr不变
			*/
			int m_dataMem[256*1000];
			qDebug() << __FUNCTION__ << m_id<< quintptr(QThread::currentThreadId()), 16, 16, QLatin1Char('0');
			QThread::msleep(1000);
		}
	}

	int m_id;
	HelloWorldTask(int id) :m_id(id) {};
	~HelloWorldTask() { qDebug() << __FUNCTION__ << m_id; }
};
int main(int argc, char *argv[])
{
	QCoreApplication a(argc, argv);

	QThreadPool	  threadpool;	           
	threadpool.setMaxThreadCount(3);         // 线程池中最大的线程数
	for (int nNum = 0; nNum < 100; nNum++)
	{
		HelloWorldTask	 *task=new HelloWorldTask(nNum);    // 循环构建可在线程池中运行的任务
		threadpool.start(task);      //线程池分配一个线程运行该任务
		QThread::msleep(1000);
	}

	return a.exec();
}
```

#### QThread 与QRunnable + QThreadPool适用的应用场景

QThread是QT的线程类，通过继承QThread然后重写run函数即可实现一个线程类。QThreadPool+ QRunnable配合构建线程池的方法也可以实现线程。我们通过以下问题对上述两种构建线程的方法进行分析和说明。

    （1）既然QThread这么简单我们为什么还要使用QThreadPool + QRunnable创建线程池的方法来使用线程机制呢？

主要原因：当线程任务量非常大的时候，如果频繁的创建和释放QThread会带来比较大的内存开销，而线程池则可以有效避免该问题，相关的基础支持可以自行百度线程池的优点。

    （2）QThread与 QThreadPool + QRunnable分别适用于哪种应用场景？

     QThread适用于那些常驻内存的任务。而且QThread可以通过信号/槽的方式与外界进行通信。而QRunnable则适用于那些不常驻内存，任务数量比较多的情况。


#### QRunnable 如何与外界进行通信

       方法1：QRunnable并不继承自QObject类，因此无法使用信号/槽的方式与外界进行通信。我们就必须的使用其他方法，这里给大家介绍的是使用：QMetaObject::invokeMethod()函数。

       方法2：使用多重继承的方法，任务子类同时继承自QRunnable和QObject。
