
```cpp
//灰度化
void ChangeColor::changeRgb(QString path, QColor color)
{
 	QImage* image = new QImage(path);
 	unsigned char* data = image->bits();//取得QImage对应的byte数组
 	int byteCount = image->byteCount();//byte数组长度
 	unsigned char* dataNew = new unsigned char[byteCount];//再申请一个一样大小的数组
    
    /*
        采用bits()方法的到的数据data中像素的组织形式应为ARGB，
        但实际调试中发现，每个像素中从字节从低到高依次是BGRA，方向刚好反过来。
    */
 	for(int i  = 0 ; i <byteCount ; i+=4)
 	{
 		unsigned char grayByte = (unsigned char)(0.30 *data[ i+2] +0.59*data[ i + 1]+0.11*data[ i]);
 		dataNew[i]     = grayByte;
 		dataNew[i+1] = grayByte;
 		dataNew[i+2] = grayByte;
 		dataNew[i+3] = data[i+3];
 	}
 	QImage* newImage = new QImage(dataNew,image->width(),image->height(),image->format());
 	newImage->save("C:\\Users\\scc\\Desktop\\old\\tme.png");
 }
```
```cpp
//像素点操作, 失败: 修改的结果是一张纯色的图片
void ChangeColor::changeRgb(QString path, QColor color)
{
 	int i=0;
 	QImage image(path);
 	for(int w = 0;w < image.width();++w)
 	{
 		for(int h = 0; h < image.height();++h)
 		{
 			QColor tmp(image.pixel(w,h));
 			if(tmp.red()==255 && tmp.green()==255 && tmp.blue()==255)continue;
 			/替换颜色
 			image.setPixel(w,h,color.rgb());
 		}
 	}
 	QPixmap pix=QPixmap::fromImage(image);
 	pix.save("./a.png");
 	ui.label_3->setPixmap(pix);
}
```

```cpp
//成功。
void ChangeColor::changeRgb(QString path, QColor color, QString savePath)
{
	QImage image(path);
	unsigned char* data = image.bits();//取得QImage对应的byte数组
	int byteCount = image.byteCount();//byte数组长度

	for(int i  = 0 ; i <byteCount ; i+=4)
	{
		if(data[i]==255 && data[i+1]==255  && data[i+2]==255 )continue;

		data[i]   = color.blue();
		data[i+1] = color.green();
		data[i+2] = color.red();
	}
	image.save(savePath);
	ui.label_3->setPixmap(QPixmap::fromImage(image));
}
```


```cpp
<color name=”mycolor”> #7fff00ff</color>
//XML定义方法接受6位和8位两种表示法，而且开头必须是#，8位定义时前两位表示透明。
aRgb:透明度、红、绿、蓝
```

作者 [@wangbin][3]     
2019 年 2月 23日 


